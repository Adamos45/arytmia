import os
from wfdb.processing import xqrs_detect
import numpy as np
from symbols_enums import FeatureNames
from features_calculation import features_calculation
import joblib
from scoring import scorer
from preprocessing import preprocessing
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler


def program_exploitation(record, record_number="", train=False, model_paths=None, classifier=0, feature_choice=None):
    feature_names = [FeatureNames.hos_mvsk, FeatureNames.db5,
                     FeatureNames.db6, FeatureNames.diffs]

    scaler = StandardScaler()

    if not train:
        beats = xqrs_detect(record, 360, verbose=False)
        record = preprocessing(record, True)
        models = []
        data = []
        if model_paths is None or len(model_paths) == 0:
            for feature in feature_names:
                data.append(features_calculation(record, beats, feature, True))
            for feature in feature_names:
                models.append(joblib.load("./trained_models/" + feature.value + ".sav"))
        else:
            feature_names.clear()
            for path in model_paths:
                feature_names.append(FeatureNames[str.rsplit(str.rsplit(path, '_', 1)[0], '/', 1)[1]])
            for feature in feature_names:
                data.append(features_calculation(record, beats, feature, True))
            for it, feature in enumerate(feature_names):
                models.append(joblib.load(model_paths[it]))
        predictions = []
        for i, feature in enumerate(feature_names):
            test_features = scaler.fit_transform(data[i]).astype(np.float64)
            if feature == FeatureNames.diffs:
                predictions.append(scorer(X=test_features, estimator=models[i], diffs=True))
            else:
                predictions.append(scorer(X=test_features, estimator=models[i]))

        ensembled_prediction = []
        for m in models:
            if len(m.classes_) != 4:
                models.remove(m)
        if len(models) == 0:
            return None
        for i in range(len(predictions[0])):
            voting = np.array(np.zeros(shape=(len(feature_names), 4)))
            for j in range(len(predictions)):
                voting[j] = predictions[j][i]
            voting = voting.T
            products = np.array(np.zeros(shape=4))
            for p in range(len(products)):
                products[p] = np.product(voting[p])
            ensembled_prediction.append(np.argmax(products))
        return ensembled_prediction
    else:
        feature_names = [FeatureNames.hos_mvsk, FeatureNames.hos_vsk,
                         FeatureNames.db5, FeatureNames.db6,
                         FeatureNames.diffs, FeatureNames.raw90,
                         FeatureNames.raw45, FeatureNames.spect]
        fn = []
        for i, f in enumerate(feature_names):
            if feature_choice[i] == 1:
                fn.append(feature_names[i])
        feature_names = fn
        if classifier == 0:
            model = MLPClassifier(hidden_layer_sizes=(20, 10, 10), max_iter=200, alpha=0.001,
                                  nesterovs_momentum=True, solver='sgd', verbose=False, tol=0.0001,
                                  learning_rate='adaptive', random_state=1)
        if classifier == 1:
            model = KNeighborsClassifier(n_neighbors=7, algorithm='auto')
        for nr, feature in enumerate(feature_names):
            data = []
            for rec in record:
                data.extend(features_calculation(rec[0], rec[1], feature))
            data = np.array(data)
            X_train = scaler.fit_transform(data[:, 0:(len(data[0]) - 1)].astype(np.float64))
            y_train = data[:, len(data[0]) - 1].astype(np.float).astype(np.int)
            model.fit(X_train, y_train)
            dir = os.listdir('.')
            if 'trained_models_gui' not in dir:
                os.mkdir('./trained_models_gui/')
            joblib.dump(model, open("./trained_models_gui/" + feature_names[nr].value + "_"
                                    + type(model).__name__ + ".sav", 'wb'))
        return None
